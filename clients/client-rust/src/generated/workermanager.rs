#![allow(unused_imports)]
#![cfg_attr(rustfmt, rustfmt_skip)]
/** THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT */
use crate::{Client, Credentials};
use failure::Error;
use serde_json::Value;
use crate::util::urlencode;

/// Worker Manager Service
///
/// This service manages workers, including provisioning for dynamic worker pools.
pub struct WorkerManager (Client);

#[allow(non_snake_case)]
impl WorkerManager {
    pub fn new(root_url: &str, credentials: Option<Credentials>) -> Result<Self, Error> {
        Ok(Self(Client::new(root_url, "worker-manager", "v1", credentials)?))
    }

    /// Ping Server
    /// 
    /// Respond without doing anything.
    /// This endpoint is used to check that the service is up.
    pub async fn ping(&self) -> Result<(), Error> {
        let method = "GET";
        let path = "ping";
        let query = None;
        let body = None;

        let resp = self.0.request(method, path, query, body).await?;

        resp.bytes().await?;
        Ok(())
    }

    /// List Providers
    /// 
    /// Retrieve a list of providers that are available for worker pools.
    pub async fn listProviders(&self, continuationToken: Option<&str>, limit: Option<&str>) -> Result<Value, Error> {
        let method = "GET";
        let path = "providers";
        let mut query = None;
        if let Some(q) = continuationToken {
            query.get_or_insert_with(Vec::new).push(("continuationToken", q));
        }
        if let Some(q) = limit {
            query.get_or_insert_with(Vec::new).push(("limit", q));
        }
        let body = None;

        let resp = self.0.request(method, path, query, body).await?;

        Ok(resp.json().await?)
    }

    /// Create Worker Pool
    /// 
    /// Create a new worker pool. If the worker pool already exists, this will throw an error.
    pub async fn createWorkerPool(&self, workerPoolId: &str, payload: &Value) -> Result<Value, Error> {
        let method = "PUT";
        let path = format!("worker-pool/{}", urlencode(workerPoolId));
        let query = None;
        let body = Some(payload);

        let resp = self.0.request(method, &path, query, body).await?;

        Ok(resp.json().await?)
    }

    /// Update Worker Pool
    /// 
    /// Given an existing worker pool definition, this will modify it and return
    /// the new definition.
    /// 
    /// To delete a worker pool, set its `providerId` to `"null-provider"`.
    /// After any existing workers have exited, a cleanup job will remove the
    /// worker pool.  During that time, the worker pool can be updated again, such
    /// as to set its `providerId` to a real provider.
    pub async fn updateWorkerPool(&self, workerPoolId: &str, payload: &Value) -> Result<Value, Error> {
        let method = "POST";
        let path = format!("worker-pool/{}", urlencode(workerPoolId));
        let query = None;
        let body = Some(payload);

        let resp = self.0.request(method, &path, query, body).await?;

        Ok(resp.json().await?)
    }

    /// Delete Worker Pool
    /// 
    /// Mark a worker pool for deletion.  This is the same as updating the pool to
    /// set its providerId to `"null-provider"`, but does not require scope
    /// `worker-manager:provider:null-provider`.
    pub async fn deleteWorkerPool(&self, workerPoolId: &str) -> Result<Value, Error> {
        let method = "DELETE";
        let path = format!("worker-pool/{}", urlencode(workerPoolId));
        let query = None;
        let body = None;

        let resp = self.0.request(method, &path, query, body).await?;

        Ok(resp.json().await?)
    }

    /// Get Worker Pool
    /// 
    /// Fetch an existing worker pool defition.
    pub async fn workerPool(&self, workerPoolId: &str) -> Result<Value, Error> {
        let method = "GET";
        let path = format!("worker-pool/{}", urlencode(workerPoolId));
        let query = None;
        let body = None;

        let resp = self.0.request(method, &path, query, body).await?;

        Ok(resp.json().await?)
    }

    /// List All Worker Pools
    /// 
    /// Get the list of all the existing worker pools.
    pub async fn listWorkerPools(&self, continuationToken: Option<&str>, limit: Option<&str>) -> Result<Value, Error> {
        let method = "GET";
        let path = "worker-pools";
        let mut query = None;
        if let Some(q) = continuationToken {
            query.get_or_insert_with(Vec::new).push(("continuationToken", q));
        }
        if let Some(q) = limit {
            query.get_or_insert_with(Vec::new).push(("limit", q));
        }
        let body = None;

        let resp = self.0.request(method, path, query, body).await?;

        Ok(resp.json().await?)
    }

    /// Report an error from a worker
    /// 
    /// Report an error that occurred on a worker.  This error will be included
    /// with the other errors in `listWorkerPoolErrors(workerPoolId)`.
    /// 
    /// Workers can use this endpoint to report startup or configuration errors
    /// that might be associated with the worker pool configuration and thus of
    /// interest to a worker-pool administrator.
    /// 
    /// NOTE: errors are publicly visible.  Ensure that none of the content
    /// contains secrets or other sensitive information.
    pub async fn reportWorkerError(&self, workerPoolId: &str, payload: &Value) -> Result<Value, Error> {
        let method = "POST";
        let path = format!("worker-pool-errors/{}", urlencode(workerPoolId));
        let query = None;
        let body = Some(payload);

        let resp = self.0.request(method, &path, query, body).await?;

        Ok(resp.json().await?)
    }

    /// List Worker Pool Errors
    /// 
    /// Get the list of worker pool errors.
    pub async fn listWorkerPoolErrors(&self, workerPoolId: &str, continuationToken: Option<&str>, limit: Option<&str>) -> Result<Value, Error> {
        let method = "GET";
        let path = format!("worker-pool-errors/{}", urlencode(workerPoolId));
        let mut query = None;
        if let Some(q) = continuationToken {
            query.get_or_insert_with(Vec::new).push(("continuationToken", q));
        }
        if let Some(q) = limit {
            query.get_or_insert_with(Vec::new).push(("limit", q));
        }
        let body = None;

        let resp = self.0.request(method, &path, query, body).await?;

        Ok(resp.json().await?)
    }

    /// Workers in a specific Worker Group in a Worker Pool
    /// 
    /// Get the list of all the existing workers in a given group in a given worker pool.
    pub async fn listWorkersForWorkerGroup(&self, workerPoolId: &str, workerGroup: &str, continuationToken: Option<&str>, limit: Option<&str>) -> Result<Value, Error> {
        let method = "GET";
        let path = format!("workers/{}:/{}", urlencode(workerPoolId), urlencode(workerGroup));
        let mut query = None;
        if let Some(q) = continuationToken {
            query.get_or_insert_with(Vec::new).push(("continuationToken", q));
        }
        if let Some(q) = limit {
            query.get_or_insert_with(Vec::new).push(("limit", q));
        }
        let body = None;

        let resp = self.0.request(method, &path, query, body).await?;

        Ok(resp.json().await?)
    }

    /// Get a Worker
    /// 
    /// Get a single worker.
    pub async fn worker(&self, workerPoolId: &str, workerGroup: &str, workerId: &str) -> Result<Value, Error> {
        let method = "GET";
        let path = format!("workers/{}:/{}/{}", urlencode(workerPoolId), urlencode(workerGroup), urlencode(workerId));
        let query = None;
        let body = None;

        let resp = self.0.request(method, &path, query, body).await?;

        Ok(resp.json().await?)
    }

    /// Create a Worker
    /// 
    /// Create a new worker.  The precise behavior of this method depends
    /// on the provider implementing the given worker pool.  Some providers
    /// do not support creating workers at all, and will return a 400 error.
    pub async fn createWorker(&self, workerPoolId: &str, workerGroup: &str, workerId: &str, payload: &Value) -> Result<Value, Error> {
        let method = "PUT";
        let path = format!("workers/{}:/{}/{}", urlencode(workerPoolId), urlencode(workerGroup), urlencode(workerId));
        let query = None;
        let body = Some(payload);

        let resp = self.0.request(method, &path, query, body).await?;

        Ok(resp.json().await?)
    }

    /// Remove a Worker
    /// 
    /// Remove an existing worker.  The precise behavior of this method depends
    /// on the provider implementing the given worker.  Some providers
    /// do not support removing workers at all, and will return a 400 error.
    /// Others may begin removing the worker, but it may remain available via
    /// the API (perhaps even in state RUNNING) afterward.
    pub async fn removeWorker(&self, workerPoolId: &str, workerGroup: &str, workerId: &str) -> Result<(), Error> {
        let method = "DELETE";
        let path = format!("workers/{}/{}/{}", urlencode(workerPoolId), urlencode(workerGroup), urlencode(workerId));
        let query = None;
        let body = None;

        let resp = self.0.request(method, &path, query, body).await?;

        resp.bytes().await?;
        Ok(())
    }

    /// Workers in a Worker Pool
    /// 
    /// Get the list of all the existing workers in a given worker pool.
    pub async fn listWorkersForWorkerPool(&self, workerPoolId: &str, continuationToken: Option<&str>, limit: Option<&str>) -> Result<Value, Error> {
        let method = "GET";
        let path = format!("workers/{}", urlencode(workerPoolId));
        let mut query = None;
        if let Some(q) = continuationToken {
            query.get_or_insert_with(Vec::new).push(("continuationToken", q));
        }
        if let Some(q) = limit {
            query.get_or_insert_with(Vec::new).push(("limit", q));
        }
        let body = None;

        let resp = self.0.request(method, &path, query, body).await?;

        Ok(resp.json().await?)
    }

    /// Register a running worker
    /// 
    /// Register a running worker.  Workers call this method on worker start-up.
    /// 
    /// This call both marks the worker as running and returns the credentials
    /// the worker will require to perform its work.  The worker must provide
    /// some proof of its identity, and that proof varies by provider type.
    pub async fn registerWorker(&self, payload: &Value) -> Result<Value, Error> {
        let method = "POST";
        let path = "worker/register";
        let query = None;
        let body = Some(payload);

        let resp = self.0.request(method, path, query, body).await?;

        Ok(resp.json().await?)
    }

    /// Reregister a Worker
    /// 
    /// Reregister a running worker.
    /// 
    /// This will generate and return new Taskcluster credentials for the worker
    /// on that instance to use. The credentials will not live longer the
    /// `registrationTimeout` for that worker. The endpoint will update `terminateAfter`
    /// for the worker so that worker-manager does not terminate the instance.
    pub async fn reregisterWorker(&self, payload: &Value) -> Result<Value, Error> {
        let method = "POST";
        let path = "worker/reregister";
        let query = None;
        let body = Some(payload);

        let resp = self.0.request(method, path, query, body).await?;

        Ok(resp.json().await?)
    }
}
